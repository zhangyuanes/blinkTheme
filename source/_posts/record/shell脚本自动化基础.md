---
title: Shell脚本自动化基础
date: 2022-09-17 14:56:00
author: zhangyuanes
categories: Record
tags:
  - Record
  - Linux
  - Shell
---

## shell介绍
### Introduce
shell是一个程序，是用户沟通linux内核的桥梁，既是一种命令语言，也是解释性的语言。

### shell功能
* 命令行解释
* 启动程序
* 输入输出的重定向
* 管道连接
* 文件名置换
* 变量维护
* 环境控制
* shell编程

## 基本语法
shell脚本就是将完成一个任务的所有命令按照执行先后的顺序，自上而下写入一个到一个文本文件中，然后赋予其执行权限。

如果在一个机器下可以执行，更换环境、更换场景是否能同时满足要求。

### 书写规范
命名：建议命名成有含义的脚本名称，最好以`.sh`命名。

解释器：书写在shell脚本的第一行，使用`#!`进行解释，跟上解释器的路径。

注意在真正的执行脚本中，执行语句不要使用任何的中文。

文件说明：书写清楚脚本的作者，创建时间，版本，脚本功能。

脚本组成： 
* 解释环境： `#!/usr/bin/bash`
* 注释说明
* 执行代码

### 运行方法
脚本的执行需要一定的权限，当给脚本文件赋予执行权限之后，该脚本就可以运行。或者指定解释器来运行。

### shell脚本中的符号
shell中的特殊符号和正则表达式中的符号有冲突的地方，所以要进行区分。

特殊符号：
* `~` 表示用户目录，使用 `cd ~`进入用户目录中，`cd -`回到上一次目录中
* `!` 表示执行历史命令，使用 `!!` 执行上一条命令，使用`history`可以查看到所有的执行命令，使用感叹号加行号就可以执行
* `$` 表示变量中取内容符号
* `+ - * / %` 表示对应的数学运算内容
* `*` shell中通配符，匹配所有
* `?` shell中通配符，匹配 除回车以外的字符
* `;` shell可以在一行中执行多条命令，命令之间用分号隔开
* `|` 管道符号，上一条命令的输出作为下一条命令的输入
* `\` 转义字符，对于有特殊含义的字符在shell如果要当作普通字符处理需要使用转义字符，转义字符本身也要转义
* ``` 反引号，在命令中执行命令，反引号框选内部命令
* `'` 单引号，脚本中的字符串需要用单引号，单引号中不解释变量
* `"` 双引号，脚本中出现的字符串可以用双引号引起来
  
### 管道
参考管道符号 `|` 将上一条命令的输出作为下一条命令的输入

### 重定向
* `>` 重定向输入，覆盖源数据
* `>>` 重定向追加输入，在原始数据的末尾添加
* `<` 重定向输出，例如 `wc -l < /etc/passwd`
* `<<` 重定向追加输出，例如 `fdisk /dev/sdb << EOF  ...   EOF`

### 数学运算
expr 命令，只能做整数运算，格式比较古板，需要注意空格和必要的转义。例如`expr 1 + 2 &>/dev/null; echo $?`，其中如果不需要打印输出则将结果重定向到`&>/dev/null`，其中 `$?` 判断上一条语句是否执行成功，如果成功则返回的为 0 ，不成功返回其他值。

```bash
# 上一条命令是否不等于0
if [ $? -ne 0 ]; then
    echo "failed"
else
    echo "succeed"
fi

# 上一条命令状态是否等于0
if [ $? -eq 0 ]; then
    echo "succeed"
else
    echo "failed"
fi
```

bc 命令，例如 `echo "scale=2;100/3" | bc`，指定小数点位数为2

`$(())`美元+括号可以直接进行运算

### 脚本退出
使用命令`exit num`退出脚本，`num`是一个整数，代表返回值，方便其他程序获得其执行结果

## 格式化输出Output
一个程序需要有`0`个或者`以上`输入，`1`个或者`更多`输出。

### echo 语法
功能：将内容输出到默认显示设备

语法： `echo [-ne][字符串]`

echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开，并在最后加上换行号

### 颜色与字体

## 格式化输入Input
### read命令

## shell变量
### 变量介绍

### 变量分类

### 变量管理

## shell数组
### 数组介绍

### 默认数组

### 关联数组

## shell运算
### 赋值

### 数学运算

### 比较运算

### 关系运算

### 文件类型比较

## 流程控制
### if
* -e 判断对象是否存在
* -d 判断对象是否存在，并且为目录
* -f 判断对象是否存在，并且为常规文件
* -L 判断对象是否存在，并且为符号链接
* -h 判断对象是否存在，并且为软链接
* -s 判断对象是否存在，并且长度不为0
* -r 判断对象是否存在，并且可读
* -w 判断对象是否存在，并且可写
* -x 判断对象是否存在，并且可执行
* -O 判断对象是否存在，并且属于当前用户
* -G 判断对象是否存在，并且属于当前用户组
* -nt 判断file1是否比file2新  [ "/data/file1" -nt "/data/file2" ]
* -ot 判断file1是否比file2旧  [ "/data/file1" -ot "/data/file2" ]


* -eq           //等于
* -ne           //不等于
* -gt            //大于
* -lt            //小于
* -ge            //大于等于
* -le            //小于等于

在if中多次判断：

*  ||                    单方成立；
*  &&                   双方都成立表达式。
### for

### while

### until

### case

## shell函数
### 介绍

### 语法

### 应用

## 正则表达式
### 介绍

### 特殊字符

### POSIX字符

## shell文件操作
### 介绍

### sed命令

### sed小技巧

## shell对输出流的处理
### awk 介绍

### awk 语法

### awk高级用法

### awk 技巧

## shell 案例
离线cache shell书写需求和优化。

### 停止系统中所有的关键字为“wings_worker”的进程
此需求中有几个关键命令： 查看系统进程，筛选含有关键字 wings_worker的进程(同时过滤掉grep本身)，获取其进程id，使用kill命令停止

```bash
ps -auxf | grep "wings_worker" | grep -v grep | awk '{print $2}' | xarge kill -9
```

其中ps命令查看的每一行结构如下：其中进程ID为第二个元素，使用awk命令可以获取。

```
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
hault.wk  98448  1.4 21.8 74171804 50265140 pts/1194 Sl Apr27 3486:19      |   \_ ./_external/usr/local/bin/wings_wo997 -hp 40998 -ap 40999 -m local -a sp-wings -c config -v 1.0 -s sp-wings --monitorPort 40088 -l config/wings_alog.ca.json -dv 0

USER：该 process 属于那个使用者账号的？
PID ：该 process 的ID。
%CPU：该 process 使用掉的 CPU 资源百分比；
%MEM：该 process 所占用的物理内存百分比；
VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
RSS ：该 process 占用的固定的内存量 (Kbytes)
TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。
STAT：该程序目前的状态，主要的状态有：
R ：该程序目前正在运作，或者是可被运作；
S ：该程序目前正在睡眠当中 (可说是 idle 状态啦！)，但可被某些讯号 (signal) 唤醒。
T ：该程序目前正在侦测或者是停止了；
Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态
START：该 process 被触发启动的时间；
TIME ：该 process 实际使用 CPU 运作的时间。
COMMAND：该程序的实际指令为何？

补充进程STAT状态：
D 无法中断的休眠状态（通常 IO 的进程）； 
R 正在运行，在可中断队列中； 
S 处于休眠状态，静止状态； 
T 停止或被追踪，暂停执行； 
W 进入内存交换（从内核2.6开始无效）； 
X 死掉的进程； 
Z 僵尸进程不存在但暂时无法消除；

W: 没有足够的记忆体分页可分配
WCHAN 正在等待的进程资源；

<: 高优先级进程
N: 低优先序进程
L: 有记忆体分页分配并锁在记忆体内 (即时系统或捱A I/O)，即,有些页被锁进内存

s 进程的领导者（在它之下有子进程）； 
l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）； 
+ 位于后台的进程组；
```

xargs 可以将**管道**或**标准输入**（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。		
-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。



